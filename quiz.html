// scripts/PhaseManager.js - VERSION CORRIG√âE COMPL√àTE
class PhaseManager {
    constructor() {
        this.currentPhase = 1;
        this.phaseTimer = CONFIG.PHASE1_TIME;
        this.phaseInterval = null;
        this.onPhaseComplete = null;
        
        // √âl√©ments DOM
        this.blackOverlay = document.getElementById('black-overlay');
        this.resultBox = document.getElementById('result-box');
        this.timerBox = document.getElementById('timer-box');
        this.timerCount = document.querySelector('.timer-count');
        this.answersSection = document.getElementById('answers-section');
        this.answersGrid = document.getElementById('answers-grid');
        
        // √âl√©ments r√©sultat
        this.resultIcon = document.querySelector('.result-icon');
        this.resultGameName = document.querySelector('.result-game-name');
        this.resultStatus = document.querySelector('.result-status');
        
        console.log('‚è±Ô∏è PhaseManager initialis√©');
    }
    
    startPhase(phaseNumber) {
        console.log(`üîÑ D√©but phase ${phaseNumber}`);
        this.currentPhase = phaseNumber;
        this.clearTimers();
        
        // Mettre √† jour la classe du body pour le CSS
        document.body.className = '';
        document.body.classList.add(`phase-${phaseNumber}`);
        
        switch(phaseNumber) {
            case 1:
                this.phaseTimer = CONFIG.PHASE1_TIME;
                this.setBlackOverlayOpacity(1);
                this.timerBox.classList.remove('hidden');
                this.timerCount.textContent = this.phaseTimer;
                this.resultBox.classList.remove('active');
                
                // Afficher les r√©ponses
                this.showAnswersSection();
                break;
                
            case 2:
                this.phaseTimer = CONFIG.PHASE2_TIME;
                this.timerBox.classList.add('hidden');
                
                // Cacher les r√©ponses IMM√âDIATEMENT
                this.hideAnswersSection();
                
                // Finaliser la r√©ponse de l'utilisateur
                this.finalizeUserAnswer();
                
                // Cr√©er et afficher l'affichage de la r√©ponse
                this.showAnswerDisplay();
                this.showResult();
                
                // FONDU du masque noir pour r√©v√©ler la vid√©o
                this.fadeOutBlackOverlay();
                
                // D√©marrer le timer de phase 2
                this.phaseInterval = setInterval(() => this.updatePhaseTimer(), 1000);
                break;
        }
    }
    
    updatePhaseTimer() {
        this.phaseTimer--;
        console.log(`‚è∞ Phase ${this.currentPhase}: ${this.phaseTimer}s restantes`);
        
        if (this.currentPhase === 1) {
            this.timerCount.textContent = this.phaseTimer;
        }
        
        if (this.phaseTimer <= 0) {
            console.log(`‚è∞ Phase ${this.currentPhase} termin√©e`);
            
            if (this.currentPhase < 2) {
                this.startPhase(2);
            } else {
                this.clearTimers();
                this.endPhase();
            }
        }
    }
    
    fadeOutBlackOverlay() {
        if (!this.blackOverlay) {
            console.error('‚ùå black-overlay non trouv√©');
            return;
        }
        
        console.log('üåÖ D√©but du fondu du masque noir');
        
        let opacity = 1;
        const duration = 3000; // 3 secondes pour le fondu
        const steps = 60; // Plus de steps pour un fondu plus smooth
        const stepDuration = duration / steps;
        const decrement = 1 / steps;
        
        let step = 0;
        const fade = () => {
            opacity -= decrement;
            this.setBlackOverlayOpacity(Math.max(0, opacity));
            
            step++;
            if (step < steps) {
                setTimeout(fade, stepDuration);
            } else {
                this.setBlackOverlayOpacity(0);
                console.log('‚úÖ Masque noir compl√®tement fondu');
            }
        };
        
        // D√©marrer le fondu
        setTimeout(fade, stepDuration);
    }
    
    fadeInBlackOverlay() {
        if (!this.blackOverlay) return;
        
        console.log('üåë D√©but du fondu entrant du masque noir');
        
        let opacity = 0;
        const duration = 3000; // 3 secondes
        const steps = 60;
        const stepDuration = duration / steps;
        const increment = 1 / steps;
        
        let step = 0;
        const fade = () => {
            opacity += increment;
            this.setBlackOverlayOpacity(Math.min(1, opacity));
            
            step++;
            if (step < steps) {
                setTimeout(fade, stepDuration);
            } else {
                this.setBlackOverlayOpacity(1);
                console.log('‚úÖ Masque noir compl√®tement r√©apparu');
            }
        };
        
        // D√©marrer apr√®s 7 secondes (10s total - 3s pour le fondu)
        setTimeout(fade, 4000);
    }
    
    setBlackOverlayOpacity(opacity) {
        if (this.blackOverlay) {
            this.blackOverlay.style.backgroundColor = `rgba(0, 0, 0, ${opacity})`;
            console.log(`üé® Opacit√© masque noir: ${opacity}`);
        }
    }
    
    // NOUVELLE M√âTHODE : Finaliser la r√©ponse de l'utilisateur
    finalizeUserAnswer() {
        if (!window.gameManager || !window.gameManager.questionManager) return;
        
        const qm = window.gameManager.questionManager;
        
        // Finaliser la s√©lection si l'utilisateur a s√©lectionn√© un bouton
        if (qm.selectedButton && !qm.userAnswered) {
            console.log('‚úÖ Finalisation de la r√©ponse utilisateur');
            qm.finalizeSelection();
        }
        
        // R√©v√©ler les bonnes/mauvaises r√©ponses
        qm.revealAnswers();
    }
    
    // NOUVELLE M√âTHODE : Afficher l'affichage de la r√©ponse
    showAnswerDisplay() {
        if (!window.gameManager || !window.gameManager.questionManager) return;
        
        const qm = window.gameManager.questionManager;
        const currentGame = qm.getCurrentGame();
        
        if (!currentGame) return;
        
        console.log(`üìù Affichage r√©ponse: ${currentGame.name}`);
        
        // Cr√©er ou mettre √† jour l'affichage de la r√©ponse
        let answerDisplay = document.getElementById('current-answer-display');
        
        if (answerDisplay) {
            answerDisplay.remove();
        }
        
        answerDisplay = document.createElement('div');
        answerDisplay.id = 'current-answer-display';
        answerDisplay.className = 'answer-display';
        
        // D√©terminer le statut
        let resultClass = 'no-answer';
        let statusText = 'PAS DE R√âPONSE';
        let icon = '‚ùå';
        
        if (qm.hasUserAnswered()) {
            if (qm.userAnswerCorrect) {
                resultClass = 'correct';
                statusText = 'CORRECT !';
                icon = 'üéâ';
            } else {
                resultClass = 'incorrect';
                statusText = 'INCORRECT';
                icon = '‚ùå';
            }
        }
        
        // Cr√©er le contenu
        answerDisplay.innerHTML = `
            <div class="answer-display-content ${resultClass}">
                <div class="answer-icon">${icon}</div>
                <div class="answer-game-name">${currentGame.name}</div>
                <div class="answer-status">${statusText}</div>
                <div class="answer-description">
                    <i class="fas fa-info-circle"></i>
                    La r√©ponse √©tait : <strong>${currentGame.name}</strong>
                </div>
            </div>
        `;
        
        // Ins√©rer dans la colonne de r√©ponses
        const answersColumn = document.querySelector('.answers-column');
        const nextBtn = document.getElementById('next-btn');
        
        if (answersColumn && nextBtn) {
            answersColumn.insertBefore(answerDisplay, nextBtn);
        } else if (answersColumn) {
            answersColumn.appendChild(answerDisplay);
        }
        
        // Ajouter la classe active pour l'animation
        setTimeout(() => {
            answerDisplay.classList.add('active');
        }, 100);
        
        // Afficher le bouton suivant
        this.showNextButton();
    }
    
    // NOUVELLE M√âTHODE : Afficher le bouton suivant
    showNextButton() {
        const nextBtn = document.getElementById('next-btn');
        if (nextBtn) {
            setTimeout(() => {
                nextBtn.style.display = 'flex';
                nextBtn.classList.add('show');
                console.log('‚ñ∂Ô∏è Bouton suivant affich√©');
                
                // Ajouter l'√©v√©nement click si pas d√©j√† fait
                if (!nextBtn.hasAttribute('data-listener-added')) {
                    nextBtn.setAttribute('data-listener-added', 'true');
                    nextBtn.addEventListener('click', () => {
                        if (window.gameManager && window.gameManager.nextQuestion) {
                            window.gameManager.nextQuestion();
                        }
                    });
                }
            }, 500);
        }
    }
    
    // NOUVELLE M√âTHODE : Afficher la section r√©ponses
    showAnswersSection() {
        if (this.answersSection) {
            this.answersSection.style.display = 'block';
            this.answersSection.style.opacity = '1';
            this.answersSection.classList.remove('hidden');
        }
        if (this.answersGrid) {
            this.answersGrid.style.display = 'grid';
            this.answersGrid.style.opacity = '1';
        }
    }
    
    // NOUVELLE M√âTHODE : Cacher la section r√©ponses
    hideAnswersSection() {
        if (this.answersSection) {
            this.answersSection.style.display = 'none';
            this.answersSection.style.opacity = '0';
            this.answersSection.classList.add('hidden');
        }
        if (this.answersGrid) {
            this.answersGrid.style.display = 'none';
            this.answersGrid.style.opacity = '0';
        }
    }
    
    showResult() {
        if (!window.gameManager || !window.gameManager.questionManager) return;
        
        const qm = window.gameManager.questionManager;
        const currentGame = qm.getCurrentGame();
        
        if (!currentGame) return;
        
        let resultClass = 'no-answer';
        let resultIcon = '‚ùå';
        let statusText = 'PAS DE R√âPONSE';
        
        if (qm.hasUserAnswered()) {
            if (qm.userAnswerCorrect) {
                resultClass = 'correct';
                resultIcon = 'üéâ';
                statusText = 'CORRECT !';
            } else {
                resultClass = 'incorrect';
                resultIcon = '‚ùå';
                statusText = 'INCORRECT';
            }
        }
        
        this.resultIcon.textContent = resultIcon;
        this.resultGameName.textContent = currentGame.name;
        this.resultStatus.textContent = statusText;
        this.resultBox.className = `result-box ${resultClass}`;
        
        setTimeout(() => {
            this.resultBox.classList.add('active');
        }, 100);
    }
    
    endPhase() {
        console.log('üèÅ Fin de phase 2 - Pr√™t pour la question suivante');
        
        this.clearTimers();
        this.resultBox.classList.remove('active');
        this.setBlackOverlayOpacity(1);
        
        // Programmer le fondu entrant du masque noir
        this.fadeInBlackOverlay();
        
        // Appeler le callback pour passer √† la question suivante
        setTimeout(() => {
            if (this.onPhaseComplete) {
                console.log('üìû Appel de onPhaseComplete');
                this.onPhaseComplete();
            }
        }, 1000);
    }
    
    clearTimers() {
        if (this.phaseInterval) {
            clearInterval(this.phaseInterval);
            this.phaseInterval = null;
        }
    }
    
    reset() {
        console.log('üîÑ Reset PhaseManager');
        this.clearTimers();
        this.currentPhase = 1;
        this.phaseTimer = CONFIG.PHASE1_TIME;
        
        // R√©initialiser les classes du body
        document.body.className = 'phase-1';
        
        this.setBlackOverlayOpacity(1);
        this.timerBox.classList.remove('hidden');
        this.timerCount.textContent = this.phaseTimer;
        this.resultBox.classList.remove('active');
        this.resultBox.className = 'result-box';
        
        // R√©afficher les r√©ponses
        this.showAnswersSection();
        
        // Supprimer l'affichage de la r√©ponse
        const answerDisplay = document.getElementById('current-answer-display');
        if (answerDisplay) {
            answerDisplay.remove();
        }
        
        // Cacher le bouton suivant
        this.hideNextButton();
    }
    
    // NOUVELLE M√âTHODE : Cacher le bouton suivant
    hideNextButton() {
        const nextBtn = document.getElementById('next-btn');
        if (nextBtn) {
            nextBtn.style.display = 'none';
            nextBtn.classList.remove('show');
        }
    }
}